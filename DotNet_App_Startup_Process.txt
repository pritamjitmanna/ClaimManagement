================================================================================
                   .NET WEB APPLICATION STARTUP PROCESS
                    Command: dotnet run --project InsuranceCompany
================================================================================

This document explains the detailed process that occurs when you execute:
    dotnet run --project InsuranceCompany

================================================================================
PHASE 1: COMMAND PARSING & PROJECT RESOLUTION
================================================================================

1. CLI Command Parsing
   - The dotnet CLI reads the command: "dotnet run --project InsuranceCompany"
   - It identifies:
       * Command: "run"
       * Project flag: "--project"
       * Project name: "InsuranceCompany"

2. Project Location Resolution
   - The CLI searches for a project file matching "InsuranceCompany"
   - Looks for: InsuranceCompany.csproj, InsuranceCompany.vbproj, etc.
   - Locates the file (typically in your Claim Management directory structure)

3. Project File Parsing
   - Reads the .csproj file (XML format)
   - Extracts metadata:
       * Target Framework (e.g., net8.0, net7.0)
       * Output Type (Exe for console/web apps)
       * Dependencies (NuGet packages)
       * Build properties
       * Assembly name and version info

================================================================================
PHASE 2: DEPENDENCY RESOLUTION
================================================================================

1. NuGet Package Resolution
   - The dotnet CLI reads the project dependencies from .csproj
   - Common NuGet packages for InsuranceCompany microservice:
       * Microsoft.EntityFrameworkCore
       * Microsoft.EntityFrameworkCore.SqlServer
       * gRPC client libraries
       * AutoMapper
       * Microsoft.AspNetCore.App (implicit for ASP.NET Core apps)
       * Swashbuckle.AspNetCore (Swagger/OpenAPI)

2. Package Restore (if needed)
   - Checks local NuGet cache for packages
   - Downloads missing packages from configured NuGet feeds (nuget.org by default)
   - Stores packages in user's .nuget folder (typically ~/.nuget/packages)
   - Resolves transitive dependencies (dependencies of dependencies)

3. Framework Resolution
   - Ensures the required .NET Runtime is installed
   - Verifies compatibility between package versions and target framework

================================================================================
PHASE 3: BUILD PROCESS
================================================================================

1. Compilation
   - The C# compiler (Roslyn) processes all .cs files in the project
   - Files included:
       * Program.cs (entry point)
       * Controllers (e.g., InsuranceCompanyController.cs)
       * Services (e.g., InsuranceCompanyService.cs)
       * DAL classes and DbContext
       * Models and DTOs
       * Middleware and configuration classes

2. IL Code Generation
   - Source code is converted to Intermediate Language (IL) code
   - IL is platform-agnostic and JIT-compiled at runtime
   - Compiler checks for syntax errors, type safety, and references

3. Assembly Creation
   - Produces: InsuranceCompany.dll (main assembly)
   - Also generates .pdb files (debugging symbols)

4. Resource Linking
   - Embeds resources (configuration files, images, etc.)
   - Copies content files to the output directory

================================================================================
PHASE 4: OUTPUT & PREPARATION
================================================================================

1. Build Output Structure
   - Creates output directory (typically bin/Debug/net8.0 or bin/Release/net8.0)
   - Contains:
       * InsuranceCompany.dll (your application assembly)
       * InsuranceCompany.deps.json (dependency manifest)
       * InsuranceCompany.runtimeconfig.json (runtime configuration)
       * All referenced NuGet package DLLs
       * appsettings.json and configuration files
       * Any other assets (wwwroot for static files if present)

2. Runtime Configuration
   - Reads InsuranceCompany.runtimeconfig.json
   - Specifies which .NET Runtime version to use
   - Defines framework versions and rollforward policies

================================================================================
PHASE 5: RUNTIME INITIALIZATION
================================================================================

1. .NET Runtime Startup
   - The dotnet host launches the CLR (Common Language Runtime)
   - Loads the .NET Runtime (matching the target framework version)
   - Initializes the GC (Garbage Collector), JIT compiler, and runtime services

2. Assembly Loading
   - Loads InsuranceCompany.dll into memory
   - Loads all referenced assemblies (System.*, Microsoft.*, NuGet packages)
   - Resolves dependencies graph and builds metadata

3. JIT Compilation
   - The JIT (Just-In-Time) compiler compiles IL code to native machine code
   - Occurs on first method invocation (not all code at startup)
   - Improves performance vs. pure interpretation

================================================================================
PHASE 6: PROGRAM EXECUTION - ENTRY POINT
================================================================================

1. Program.cs Execution Begins
   - The entry point is Program.cs (top-level statements in modern .NET 6+)
   - Execution order:
       a) Create WebApplicationBuilder
          - new WebApplication.CreateBuilder(args)
          - Reads command-line arguments and configuration sources

       b) Dependency Injection Container Setup
          - builder.Services.AddDbContext<InsuranceCompanyDBContext>(...)
            → Registers EF Core DbContext with SQL Server provider
            → Configures connection string from appsettings.json

          - builder.Services.AddGrpcClient<ClaimsService.ClaimsServiceClient>(...)
            → Registers typed gRPC client for inter-service communication
            → Sets base address from configuration

          - builder.Services.AddScoped<IService, ServiceImplementation>()
            → Registers BLL services and DAL repositories
            → Sets lifetime (Scoped = one per HTTP request)

          - builder.Services.AddAutoMapper(typeof(MapperProfile))
            → Registers AutoMapper and scans profiles
            → Enables DTO<->Entity mapping

          - builder.Services.AddControllers()
            → Registers MVC/Web API controllers
            → Configures JSON options (enum as string, null handling, etc.)

          - builder.Services.AddSwaggerGen()
            → Enables OpenAPI (Swagger) metadata generation

       c) Build WebApplication
          - WebApplication app = builder.Build()
          - Creates the application pipeline from the configured services
          - Initializes the request processing pipeline

================================================================================
PHASE 7: MIDDLEWARE PIPELINE CONFIGURATION
================================================================================

1. Middleware Ordering (Important!)
   The order matters; middleware processes requests in order and responses in reverse:

   a) Routing
      - app.UseRouting()
      - Determines which controller/action handles the request

   b) HTTPS Redirection (if enabled)
      - app.UseHttpsRedirection()
      - Redirects HTTP requests to HTTPS

   c) Swagger/OpenAPI (Development only)
      - if (app.Environment.IsDevelopment())
      - Enables /swagger/index.html and /swagger/v1/swagger.json endpoints

   d) Authentication
      - app.UseAuthentication()
      - Validates JWT tokens or other auth schemes
      - Populates HttpContext.User with claims

   e) Authorization
      - app.UseAuthorization()
      - Checks if authenticated user has required permissions/roles
      - Must come AFTER authentication

   f) Endpoint Mapping
      - app.MapControllers()
      - Maps attribute-routed endpoints to controller methods

================================================================================
PHASE 8: DATABASE INITIALIZATION
================================================================================

1. EF Core Initialization (Implicit)
   - When first DbContext query is executed:
       * Connection string is retrieved from configuration
       * SQL Server connection is opened
       * Database connection pool is created
       * EF Core metadata is built (via reflection on entity classes)

2. Database & Schema Verification
   - Checks if database exists
   - If using migrations:
       * Applies pending migrations (creates/alters tables)
       * Updates __EFMigrationsHistory table
       * Seeds initial data (via HasData() in OnModelCreating)

3. Connection Pooling
   - Maintains a pool of reusable database connections
   - Improves performance by reusing connections vs. creating new ones

================================================================================
PHASE 9: gRPC CLIENT INITIALIZATION
================================================================================

1. gRPC Channel Creation
   - When first gRPC call is made:
       * Creates HTTP/2 channel to the remote service address
       * Address: configured from appsettings.json (e.g., https://localhost:5001)
       * Reuses channel across multiple service calls (singleton by default)

2. Proto Message Deserialization
   - Loads generated .proto service stubs
   - Sets up serialization/deserialization for gRPC messages
   - Uses protobuf (efficient binary format)

================================================================================
PHASE 10: APPLICATION READY & LISTENING
================================================================================

1. Server Startup
   - app.Run()
   - Starts Kestrel (the default ASP.NET Core web server)
   - Binds to configured endpoints (typically http://localhost:5000 and https://localhost:5001)

2. Console Output
   - Displays startup logs:
       * "info: Microsoft.Hosting.Lifetime[0] Now listening on: https://localhost:5001"
       * "info: Microsoft.Hosting.Lifetime[0] Now listening on: http://localhost:5000"
       * "info: Microsoft.Hosting.Lifetime[0] Application started. Press Ctrl+C to shut down."
       * "info: Microsoft.Hosting.Lifetime[14] Hosting environment: Development"

3. Ready for Requests
   - Application is now running and accepting HTTP/gRPC requests
   - All registered services are available
   - DI container is ready to resolve dependencies

================================================================================
PHASE 11: REQUEST HANDLING LIFECYCLE (Per Incoming Request)
================================================================================

When a client request arrives (e.g., POST /api/insurancecompany/addclaim):

1. Request Reception
   - Kestrel receives the HTTP request
   - Creates HttpContext containing request/response data

2. Middleware Pipeline Execution
   - Request flows through middleware in order:
       a) Routing determines the target controller/action
       b) Authentication validates the JWT token
       c) Authorization checks user roles/claims
       d) Mapping routes to the specific endpoint

3. Dependency Injection Resolution
   - DI container creates controller instance
   - Injects dependencies (services, repositories, etc.)
   - Constructor injection happens here

4. Controller Action Execution
   - Calls the action method (e.g., AddNewClaim)
   - Service layer performs business logic
   - May call other services or gRPC endpoints

5. Database Operations (if needed)
   - EF Core queries/inserts/updates via DbContext
   - SQL commands are sent to SQL Server
   - Results are mapped back to entities/DTOs

6. Response Building
   - Action returns IActionResult (Ok, BadRequest, etc.)
   - Serializes response to JSON (using configured JsonSerializerOptions)
   - Sets status code and headers

7. Middleware Pipeline Returns (Reverse Order)
   - Response flows back through middleware in reverse
   - Middleware can inspect/modify response
   - Finally sent to client

================================================================================
PHASE 12: SHUTDOWN
================================================================================

When you press Ctrl+C or the process receives a shutdown signal:

1. Graceful Shutdown Initiated
   - IHostApplicationLifetime.ApplicationStopping event fires
   - In-flight requests are allowed to complete (within timeout)
   - New requests are rejected with 503 Service Unavailable

2. Resource Cleanup
   - DbContext connections are closed and returned to pool
   - gRPC channels are gracefully closed
   - Hosted services are stopped

3. Process Termination
   - .NET Runtime is unloaded
   - Process exits with exit code 0 (success)

================================================================================
KEY CONFIGURATION FILES INVOLVED
================================================================================

1. appsettings.json
   - Contains runtime configuration
   - Connection strings for databases
   - URLs for gRPC services
   - JWT settings (issuer, audience, secret)
   - Logging levels

2. appsettings.Development.json
   - Overrides for Development environment
   - May enable detailed error pages
   - May change logging verbosity

3. .csproj File
   - Project metadata and dependencies
   - Build configuration
   - NuGet package references
   - Target framework specification

4. configuration.json (for Gateway/Ocelot)
   - Routes definition for API Gateway
   - Claim-based authorization rules
   - Downstream service mappings

================================================================================
SUMMARY TIMELINE
================================================================================

1. dotnet run command invoked
2. Project parsed, dependencies resolved
3. Code compiled to IL
4. Build output generated
5. .NET Runtime started
6. Program.cs executed
7. DI container configured
8. Middleware pipeline built
9. Database connections initialized
10. gRPC clients prepared
11. Kestrel server listens on endpoints
12. Application ready for requests
13. Requests handled via DI/middleware pipeline
14. Ctrl+C triggers graceful shutdown

================================================================================
PERFORMANCE CONSIDERATIONS
================================================================================

- JIT Compilation Overhead: First requests may be slower (warm-up)
- Connection Pooling: Reuses DB connections for efficiency
- gRPC vs REST: gRPC is more efficient (HTTP/2, binary)
- Dependency Injection: Runtime cost but enables testability
- Entity Framework: Lazy loading or eager loading affects DB queries
- Logging: Configure appropriately (too verbose = performance impact)

================================================================================
END OF DOCUMENT
================================================================================